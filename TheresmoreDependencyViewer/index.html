<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TDV</title>
  <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

  <style>
    body {
      font-family: sans-serif;
      background: #f2f2f2;
    }
    textarea {
      width: 100%;
      height: 200px;
      font-family: monospace;
    }
    button {
      padding: 0.5em 1em;
      font-size: 1em;
    }
    label {
      margin-right: 20px;
    }
    input[type="checkbox"]{
      margin-right: 0;
    }
    g g text{
      cursor: pointer;
    }
    .foundNode{
      animation: blinkHighlight .5s linear;
    }
    
    @keyframes blinkHighlight {
      0%   { stroke: #000000; stroke-width: 0px; }
      20%   { stroke: #ff0000; stroke-width: 1px; }
      40%   { stroke: #aaaa00; stroke-width: 2px; }
      60%  { stroke: #00ff00; stroke-width: 3px; }
      80%  { stroke: #00aaaa; stroke-width: 2px; }
      100% { stroke: #0000ff; stroke-width: 1px; }
    }

  </style>
</head>
<body>
  <h2>Theresmore Dependency Viewer</h2>
  <div id='top'>
    <p>
      This is a bodged together site with a lot of AI generated code. It is used to generate dependancy graphs based on the game <a href="https://www.theresmoregame.com/play/#">TheresMore</a>.
    </p>
    <p>
      You can use a pre-saved version from 2025-08-08 by clicking 'Generate' below or save and upload the current JS.
      Find/save the main.js from <a href="https://www.theresmoregame.com/play/#">TheresMore</a>
    </p>
    <p>
      Upload the file here:
      <input type="file" id="fileInput" />
    </p>
  
    <hr/>
    <p>
      Select sections to include in graph.<br/>
      <small>
        Note: required nodes to selected groups will be included.</br>
        Example: if buildings are the only group selected then 'housing' will still be included because 'common_house' requires that tech.<br/>
      </small>
    </p>
    
    <input type="checkbox" id="chkBuilding" checked />
    <label for="chkBuilding">building</label>
    
    <input type="checkbox" id="chkEnemy" checked />
    <label for="chkEnemy">enemy</label>
    
    <input type="checkbox" id="chkDiplomacy" checked />
    <label for="chkDiplomacy">diplomacy</label>
  
    <input type="checkbox" id="chkLegacy" checked />
    <label for="chkLegacy">legacy</label>
  
    <input type="checkbox" id="chkPrayer" checked />
    <label for="chkPrayer">prayer</label>
  
    <input type="checkbox" id="chkResource" checked />
    <label for="chkResource">resource</label>
  
    <input type="checkbox" id="chkTech" checked />
    <label for="chkTech">tech</label>
  
    <input type="checkbox" id="chkUnits" checked />
    <label for="chkUnits">units</label>
    
    <br/>
    
    <input type="checkbox" id="chkFilterOrphans" checked/>
    <label for="chkFilterOrphans">Filter Orphans (Do not include unconnected nodes)</label>
    <br/>
    <input type="checkbox" id="chkToggleOutputs" checked onchange="toggleOutputs(this.checked)"/>
    <label for="chkToggleOutputs">Hide JSON/Graphviz (Show for debugging)</label>
    
  
    <hr/>
    
    <button id='GOTIME' onClick="GOTIME()">Generate</button>
    
    <br/>
    <button id="CLEAR" style="display:none;" onClick="CLEAR()">Clear Outputs</button>
    <textarea id="parsed" style="display:none;" placeholder="JSON will appear here..."></textarea>
    <textarea id="graphviz" style="display:none;" placeholder="graphviz dot syntax will appear here, copy to the Graphviz viewer below..."></textarea>
  
  </div>
  <div id='bottom' style="display:none;">
    <div id='redo' style="float:right;position:fixed;right:10px;top:10px;display: flex;">
      <div style="margin-right:30px;">
        <button onclick="downloadSVG()">Download Chart</button>
      </div>
      <button onclick='redo()'>Chart Settings</button>
    </div>
    
    <div style="width:100vw; display:flex" >
      <div id="zoom-controls" style="position:absolute; bottom: 20px; left: 10px;display:flex; flex-direction:row; gap: 2px;">
        <div id="zoomIndicator" style="margin:5px; font-family:sans-serif;display:flex; flex-direction:column; gap: 2px;">
          <button style="width:30px; padding:0; margin:0;" onclick="adjustZoom(.1);">+</button>
          <button style="width:30px; padding:0; margin:0;" onclick="resetZoom()">=</button>
          <button style="width:30px; padding:0; margin:0;" onclick="adjustZoom(-.1)">−</button>
          <span id="zoomValue">1.00</span>
        </div>
        
        <div syle="display:flex; flex-direction:column; gap: 2px">
          <div id="pan-controls" style="display: grid; grid-template-columns: 30px 30px 30px; grid-template-rows: 30px 30px 30px; gap: 2px;">
            <div></div>
            <button style="width:30px; padding:0; margin:0;" onclick="panZoomInstance.panBy({x: 0, y: 500}); updatePanLoc();">↑</button>
            <div></div>
          
            <button style="width:30px; padding:0; margin:0;" onclick="panZoomInstance.panBy({x: 500, y: 0}); updatePanLoc();">←</button>
            <button style="width:30px; padding:0; margin:0;" onclick="findNode('node1')">⊙</button>
            <button style="width:30px; padding:0; margin:0;" onclick="panZoomInstance.panBy({x: -500, y: 0}); updatePanLoc();">→</button>
          
            <div></div>
            <button style="width:30px; padding:0; margin:0;" onclick="panZoomInstance.panBy({x: 0, y: -500}); updatePanLoc();">↓</button>
            <div></div>
          </div>
          <span id="curLocX"></span>x<span id="curLocY"></span>
        </div>
    </div>

      <div id="svgOutput" style="width:75vw; height:calc(95vh - 30px); overflow:hidden; border:1px solid #ccc; margin:0;"></div>
      <div id="divRight" style="width:23vw; height:calc(95vh - 30px); overflow:auto; border:1px solid #ccc; margin:0;">
        <input id="txtSearch" style="width:97%; height: 30px;"/>
        <button id="btnSearch" style="width:99%; height: 30px;" onclick="findNodeByText(document.getElementById('txtSearch').value);">Search</button>
        <select id='nodeFinder' style="width:99%; height:30px" placeholder="Select node to pan" onchange="findNode(this.value); showDetails(findItems(this.options[this.selectedIndex].text));"></select>
        <pre id="divDetails" style="width:100%; height:calc(95vh - 90px); overflow:auto; border:1px solid #ccc; margin:0;"></pre>
      </div>
    </div>
  </div>

  <script>
    const dataSets = {};

   // Shared function to extract matches
    function extractArrays(content, regex) {
      const matches = content.match(regex);
      return matches || [];
    }

    // Define all your regex patterns here
    const patterns = [
      {
        label: 'building',
        regex: /\{[^}]*?id\s*:\s*["']common_house["'][^}]*?cat\s*:\s*["']living_quarters["'][^}]*?\}/g
      },
      {
        label: 'enemy',
        regex: /\{[^}]*?id\s*:\s*["']ancient_burial_place["'][^}]*?army\s*:\s*\[/g
      },
      {
        label: 'diplomacy',
        regex: /\{[^}]*?id\s*:\s*["']nightdale_protectorate["'][^}]*?relationship\s*:\s*30[^}]*?\}/g
      },
      {
        label: 'legacy',
        regex: /\{[^}]*?id\s*:\s*["']ancient_treasury["'][^}]*?req\s*:\s*\[/g
      },
      {
        label: 'prayer',
        regex: /\{[^}]*?id\s*:\s*["']praise_gods["'][^}]*?type\s*:\s*["']prayer["'][^}]*?\}/g
      },
      {
        label: 'resource',
        regex: /\{[^}]*?id\s*:\s*["']research["'][^}]*?cap\s*:\s*500[^}]*?\}/g
      },
      {
        label: 'tech',
        regex: /\{[^}]*?id\s*:\s*["']trading_woods["'][^}]*?req\s*:\s*\[[\s\S]*?gen\s*:\s*\[[\s\S]*?\][^}]*?\}/g
      },
      {
        label: 'unit',
        regex: /\{[^}]*?id\s*:\s*["']settlement_defenses["'][^}]*?type\s*:\s*["']settlement["'][^}]*?\}/g
      },
    ];
    
    function extractArrayAroundObject(content, regex) {
      if(!regex) {return null;}
      const objectMatch = regex.exec(content);
      if (!objectMatch) {
        console.log(`No object found with regex ${regex}`);
        return null;
      }
    
      const startIndex = objectMatch.index;
    
      // Walk backward to find the opening bracket of the array
      let arrayStart = startIndex;
      while (arrayStart > 0 && content[arrayStart] !== '[') {
        arrayStart--;
      }
    
      // Walk forward to find the closing bracket of the array
      let arrayEnd = arrayStart;
      let bracketDepth = 0;
      let inString = false;
      let stringChar = '';
      let escaped = false;
    
      for (let i = arrayStart; i < content.length; i++) {
        const char = content[i];
    
        if (inString) {
          if (escaped) {
            escaped = false;
          } else if (char === '\\') {
            escaped = true;
          } else if (char === stringChar) {
            inString = false;
          }
          continue;
        }
    
        if (char === '"' || char === "'") {
          inString = true;
          stringChar = char;
          continue;
        }
    
        if (char === '[') {
          bracketDepth++;
        } else if (char === ']') {
          bracketDepth--;
          if (bracketDepth === 0) {
            arrayEnd = i + 1;
            break;
          }
        }
      }
    
      if (bracketDepth !== 0) {
        console.warn('Failed to find complete array');
        return null;
      }
    
      const arrayText = content.slice(arrayStart, arrayEnd);
      return arrayText;
    }
  
    function toggleOutputs(hide){
      document.getElementById('CLEAR').style.display = hide ? 'none' : 'block';
      document.getElementById('parsed').style.display = hide ? 'none' : 'block';
      document.getElementById('graphviz').style.display = hide ? 'none' : 'block';
    }
  
    function removeResourceReqs(data) {
      const output = data.map(item => {
        // Copy only relevant properties
        const { id, req, reqFound, type, gen } = item;
        const temp = (req ||[]).concat(reqFound||[]);//combine to get a single req list
        return {
          id,
          type,
          res: temp?.filter(r => r.type === "resource"),//get all the resources
          req: temp?.filter(r => r.type !== "resource"),//get all the not resources
          gen: gen
          
        };
      });
      return output;
    }
    
    function parseData() {
      const b = removeResourceReqs(dataSets.building || []);
      const e = removeResourceReqs(dataSets.enemy || []);
      const d = removeResourceReqs(dataSets.diplomacy || []);
      const l = removeResourceReqs(dataSets.legacy || []);
      const p = removeResourceReqs(dataSets.prayer || []);
      const r = removeResourceReqs(dataSets.resource || []);
      const t = removeResourceReqs(dataSets.tech || []);
      const u = removeResourceReqs(dataSets.unit || []);
    
      let included = [];
      if(document.getElementById('chkBuilding').checked){
        included = included.concat(b);
      }
      if(document.getElementById('chkEnemy').checked){
        included = included.concat(e);
      }
      if(document.getElementById('chkDiplomacy').checked){
        included = included.concat(d);
      }
      if(document.getElementById('chkLegacy').checked){
        included = included.concat(l);
      }
      if(document.getElementById('chkPrayer').checked){
        included = included.concat(p);
      }
      if(document.getElementById('chkTech').checked){
        included = included.concat(t);
      }
      if(document.getElementById('chkUnits').checked){
        included = included.concat(u);
      }
    
      document.getElementById('parsed').value = JSON.stringify(included, null, 2);
      return included;
    }
    
    function getType(input){
        if(dataSets.building.some(x => x.id === input)){
          return 'building';
        }
        else if(dataSets.enemy.some(x => x.id === input)){
          return 'enemy';
        }
        else if(dataSets.diplomacy.some(x => x.id === input)){
          return 'diplomacy';
        }
        else if(dataSets.legacy.some(x => x.id === input)){
          return 'legacy';
        }
        else if(dataSets.prayer.some(x => x.id === input)){
          const x = dataSets.prayer.find(x => x.id === input);
          return x.type;
        }
        else if(dataSets.resource.some(x => x.id === input)){
          return 'resource';
        }
        else if(dataSets.tech.some(x => x.id === input)){
          return 'tech';
        }
        else if(dataSets.unit.some(x => x.id === input)){
          return 'unit';
        }
        return 'N/A';
      //TODO: build types; this is placeholder for testing
      return 'building';
    }
    
    function buildVizDep(input) {
      const output = [];
      
      input.req?.forEach(x => {
          const label = x.value > 1 ? `[label = ${x.value}]` : '';
          output.push(`  ${x.id} -> ${input.id} ${label}`)
      });
      return output;
    }
    
    function hasDep(input, all){
        const dep = all.some(x => x.req?.some(y => y.id === input.id));
        return dep.length > 0;
    }
    
    function formatNumber(input){
      
      if(isNaN(input)) { return input; }
      
      if(input % 1000999 === 0){return `${input/1000000}M`;}
      if(input % 1000 === 0){return `${input/1000}K`;}
      return input;
    }
    
    function buildGraphViz(input){
      const types = {
        building: new Set(),
        enemy: new Set(),
        diplomacy: new Set(),
        legacy: new Set(),
        prayer: new Set(),
        spell: new Set(),
        resource: new Set(),
        cap: new Set(),
        stat: new Set(),
        tech: new Set(),
        unit: new Set()
      };
      
      const fo = document.getElementById('chkFilterOrphans')?.checked;
      const nodes = fo ? input.filter(x => x.req?.length || hasDep(x, input)) : input;
      
      const resNodes = nodes.filter(x => x.res.length > 0)
        .sort((a,b) => a.id.localeCompare(b.id))
        .map(n => `   ${n.id} [tooltip = "${n.res.map(r => `${r.id}&#9;${formatNumber(r.value)}`).join('&#13;&#10;')}"]` );

      const deps = nodes.map(x => {
        const type = getType(x.id);

        if(types.hasOwnProperty(type)) { types[type].add(x.id); }
        else{console.log("IDK TYPE0", x)}
        x.req?.forEach(y => {
          const rType = y.type || getType(y.id);
          if(types.hasOwnProperty(rType)) { types[rType].add(y.id); }
          else if(rType.startsWith('diplomacy')) {types.diplomacy.add(y.id);}
          else if(rType === 'army') {types.unit.add(y.id);}
          else{console.log("IDK TYPE1", x, y)}
        })
        
        return buildVizDep(x);
      }).flat().filter(x => x);

      const lines = [];
      
      const special = [];
      if(deps.some(x => x.includes('theresmore_richest_nation'))){ special.push('coin;'); }
      if(deps.some(x => x.includes('mausoleum_gods'))){ special.push('tome_wisdom;'); }
      if(deps.some(x => x.includes('reactivate_portal'))){ special.push('relic;'); }
      if(deps.some(x => x.includes('titan_gift_t'))){ special.push('titan_gift;'); }
      const gems = [];
      if(deps.some(x => x.includes('statue_virtue'))){ gems.push('gem0;'); }
      if(deps.some(x => x.includes('fortified_citadel'))){ gems.push('gem1;'); }
      if(deps.some(x => x.includes('holy_site'))){ gems.push('gem2;'); }
      const gemNode = gems.length>0?`   {node [label="gem"] ${gems.join(' ')}}`:'';
      
      if(deps.some(x => x.includes('plenty_valley'))){ types.resource.add('food'); }
      if(deps.some(x => x.includes('commercial_monopolies'))){ types.resource.add('gold'); }
      

      lines.push('digraph TM {');
      lines.push('  fontname="Helvetica,Arial,sans-serif"');
	    lines.push('  node [fontname="Helvetica,Arial,sans-serif"]');
      lines.push('  edge [fontname="Helvetica,Arial,sans-serif"]');
      lines.push('  overlap=false;');
      lines.push('  subgraph cluster_key {');
      lines.push('    label="Key";');
      lines.push('    style=dashed;');
      lines.push('    fontsize=12;');
      lines.push('    rank=min;');
      lines.push('    rankdir=TB;');
      lines.push('    key_special_resource [label="Special Resource" shape=house style=filled fillcolor="#ff5555"];');
      lines.push('    key_building [label="Building" shape=ellipse style=filled fillcolor="#ffff55"];');
      lines.push('    key_enemy [label="Enemy" shape=octagon style=filled fillcolor="#ffaa55"];');
      lines.push('    key_diplomacy [label="Diplomacy" shape=octagon style=filled fillcolor="#aaff55"];');
      lines.push('    key_legacy [label="Legacy" shape=invhouse style=filled fillcolor="#55ff55"];');
      lines.push('    key_prayer [label="Prayer" shape=house style=filled fillcolor="#55ffaa"];');
      lines.push('    key_spell [label="Spell" shape=house style=filled fillcolor="#55ffff"];');
      lines.push('    key_resource [label="Resource" shape=house style=filled fillcolor="#55aaff"];');
      lines.push('    key_tech [label="Tech" shape=box style=filled fillcolor="#7777ff"];');
      lines.push('    key_unit [label="Unit" shape=box style=filled fillcolor="#ff77ff"];');
      lines.push('    key_resets [label="Resets" shape=star style=filled fillcolor="#ff0000"];');
      lines.push('  }');
      if(special.length + gems.length > 0){
        lines.push('  //special resource');
        lines.push('  node [shape=house style=filled fillcolor="#ff5555"];');
        lines.push(`    ${special.join(' ')}`);
        lines.push(gemNode);
      }
      if(types.building.size){
        lines.push('  //building');
        lines.push('  node [shape=ellipse style=filled fillcolor="#ffff55"];');
        lines.push(`    ${Array.from(types.building).join('; ')};`);
      }
      if(types.enemy.size){
        lines.push('  //enemy');
        lines.push('  node [shape=octagon style=filled fillcolor="#ffaa55"];');
        lines.push(`    ${Array.from(types.enemy).join('; ')};`);
      }
      if(types.diplomacy.size){
        lines.push('  //diplomacy');
        lines.push('  node [shape=octagon style=filled fillcolor="#aaff55"];');
        lines.push(`    ${Array.from(types.diplomacy).join('; ')};`);
      }
      if(types.legacy.size){
        lines.push('  //legacy');
        lines.push('  node [shape=invhouse style=filled fillcolor="#55ff55"];');
        lines.push(`    ${Array.from(types.legacy).join('; ')};`);
      }
      if(types.prayer.size){
        lines.push('  //prayer');
        lines.push('  node [shape=house style=filled fillcolor="#55ffaa"];');
        lines.push(`    ${Array.from(types.prayer).join('; ')};`);
      }
      if(types.spell.size){
        lines.push('  //spell');
        lines.push('  node [shape=house style=filled fillcolor="#55ffff"];');
        lines.push(`    ${Array.from(types.spell).join('; ')};`);
      }
      if(types.resource.size){
        lines.push('  //resource');
        lines.push('  node [shape=house style=filled fillcolor="#55aaff"];');
        lines.push(`    ${Array.from(types.resource).concat(Array.from(types.cap)).join('; ')};`);
      }
      if(types.tech.size){
        lines.push('  //tech');
        lines.push('  node [shape=box style=filled fillcolor="#7777ff"];');
        lines.push(`    ${Array.from(types.tech).join('; ')};`);
      }
      if(types.unit.size){
        lines.push('  //unit');
        lines.push('  node [shape=box style=filled fillcolor="#ff77ff"];');
        lines.push(`    ${Array.from(types.unit).join('; ')};`);
      }
      lines.push('  //other (NG+)');
      lines.push('  node [shape=star style=filled fillcolor="#ff0000"];');
      lines.push('  ');
      
      resNodes.forEach(x => lines.push(x));
      deps.forEach(x => lines.push(x));

      if(deps.some(x => x.includes('end_era_4_1'))){ lines.push('  end_era_4_1 -> end_4'); }
      if(deps.some(x => x.includes('end_era_4_2'))){ lines.push('  end_era_4_2 -> end_4'); }
      
      if(deps.some(x => x.includes('theresmore_richest_nation'))){ lines.push('  theresmore_richest_nation -> coin'); }
      if(deps.some(x => x.includes('mausoleum_gods'))){ lines.push('  mausoleum_gods -> tome_wisdom'); }
      if(deps.some(x => x.includes('reactivate_portal'))){ lines.push('  reactivate_portal -> relic'); }
      if(deps.some(x => x.includes('titan_gift_t'))){ lines.push('  titan_gift_t -> titan_gift'); }
      if(deps.some(x => x.includes('statue_virtue'))){ lines.push('  statue_virtue -> gem0'); }
      if(deps.some(x => x.includes('fortified_citadel'))){ lines.push('  fortified_citadel -> gem1'); }
      if(deps.some(x => x.includes('holy_site'))){ lines.push('  holy_site -> gem2'); }
      lines.push('}');
      
      return lines.join('\n');
    }
    
    function showDetails(input){
      const div = document.getElementById('divDetails');
      div.textContent = JSON.stringify(input, null, 2);
      setTimeout(() => document.getElementById('svgOutput').querySelector('svg').querySelectorAll('.foundNode').forEach(n => n.classList.remove('foundNode')), 500);
    }
    
    function findItems(input){
      const matches = [];
      
      Object.values(dataSets).forEach(x => {
        const match = x.filter(y => y.id === input);
        if(match.length > 0){
          matches.push(match);
        }
        
      })
      
      const output = matches.flat();
      return output;
    }

    function renderSVG(input){
      const viz = new Viz();
      const svgContainer = document.getElementById('svgOutput');
      svgContainer.replaceChildren();

      viz.renderSVGElement(input)
        .then(function(element) {
          document.getElementById("svgOutput").appendChild(element);
          
          const svg = svgContainer.querySelector('svg');
          
          if (!svg) {
            console.warn('Could not find SVG node.');
            return;
          }
        
          svg.addEventListener('click', function (e) {
            const target = e.target;
            // Check if the clicked element is a <text> or inside one
            let textElement = target.closest('text') || target.closest('tspan');
            if (textElement) {
              const clickedText = textElement.textContent.trim();
              showDetails(findItems(clickedText));
            }
          });
          
          svg.addEventListener('mouseup', updatePanLoc);
        })
      .catch(function(error) {
        console.error("Viz.js error:", error);
      });
      
    }
    
        
    function buildDataSets(content){
      if(!content){
        Object.keys(dataSets).forEach(key => delete dataSets[key]);
      }
      
      patterns.forEach(({ label, regex }) => {
        const arrayText = extractArrayAroundObject(content, regex);
        if (arrayText) {
          try {
            dataSets[label] = eval(arrayText);
          } catch (err) {
            console.warn(`Failed to parse ${label}:`, err);
          }
        }
        
        try {
          const parsedArray = eval(arrayText);
          dataSets[label] = parsedArray;
        } catch (err) {
          console.warn(`Failed to parse ${label}:`, err);
        }
      });
      parseData();
    }
    
    function readerOnload(e) {
      buildDataSets(e.target.result)
    }
    
    function loadDefault(){
      fetch('./default.txt')
      .then(response => {
        if (!response.ok) {
          throw new Error(`Failed to load default.txt: ${response.statusText}`);
        }
        return response.text();
      })
      .then(content => {
        buildDataSets(content);
        GOTIME();
      })
      .catch(error => {
        console.error('Error loading default file:', error);
      });
    }
    loadDefault();

    document.getElementById('fileInput').addEventListener('change', function (event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = readerOnload;
      reader.readAsText(file);
    });
        
    function findNode(nodeId) {
      const svg = document.querySelector('#svgOutput svg');
      const node = svg.querySelector(`#${CSS.escape(nodeId)}`);
      if (!node) {
        console.warn(`Node "${nodeId}" not found.`);
        return;
      }
      console.log("foundNode", node);
      
      
      svg.querySelectorAll('.foundNode').forEach(n => n.classList.remove('foundNode'));
      node.classList.add('foundNode');
      setTimeout(() => {
        node.classList.remove('foundNode');
      }, 1000);
      

      const viewport = panZoomInstance.getSizes();
      const bbox = node.getBBox();
      const ctm = node.getCTM();

      const Y = ctm.d * (bbox.y + viewport.viewBox.height);
      const X = ctm.a * bbox.x;
      
      const offsetX = (svg.parentNode.clientWidth / 2) - (bbox.width / 2);
      const offsetY = (svg.parentNode.clientHeight / 3) - (bbox.height / 2);
    
      panZoomInstance.pan({x: -X + offsetX, y: -Y + offsetY});
      updatePanLoc();
    }

    function findNodeByText(text) {
      const svg = document.querySelector('#svgOutput svg');
      const texts = svg.querySelectorAll('text');
    
      const matches = [];
      const a = text.trim().toLowerCase().replaceAll(' ', '_');
      for (const t of texts) {
        const b = t.textContent.trim();
        if (a.includes(b) || b.includes(a)) {
          matches.push(t.closest('g'));
        }
      }
    
      const select = document.getElementById('nodeFinder');
      select.innerHTML = ''; // Clear previous options
      const option = document.createElement('option');
      
      option.textContent = "<- Select Node ->";
      select.appendChild(option);

      
      matches.map(x => ({id: x.id, value: x.getElementsByTagName('text')[0].textContent}))
          .sort((a,b) => a.value.localeCompare(b.value)).forEach(x => {
        const option = document.createElement('option');
        
        option.value = x.id;
        option.textContent = x.value;
        select.appendChild(option);
      });
          
      return matches;
    }
    
    function resetZoom() {
      panZoomInstance.reset();
      panZoomInstance.fit();
      panZoomInstance.center();
      updateZoomIndicator(panZoomInstance.getZoom());
    }

    function adjustZoom(delta) {
      const pan = panZoomInstance.getPan();
      const oldZoom = panZoomInstance.getZoom();
      const newZoom = oldZoom + delta;
      if(newZoom > 2.05 || newZoom < .1){return;}
      
      panZoomInstance.zoom(newZoom);
      panZoomInstance.pan({x: pan.x / oldZoom * newZoom, y: pan.y / oldZoom * newZoom});

      updateZoomIndicator(panZoomInstance.getZoom());
    }
  
    function setupZoom(svg) {
      const panZoomInstance = svgPanZoom(svg, {
        zoomEnabled: false,
        panEnabled: true,
        controlIconsEnabled: true,
        fit: true,
        center: true,
        minZoom: 0.1,
        maxZoom: 2,
        zoomScaleSensitivity: 0.2,
        beforeZoom: function(oldZoom, newZoom) {
          updateZoomIndicator(newZoom);
        }
      });
    
      // Initial value
      updateZoomIndicator(panZoomInstance.getZoom());
      

      if (window.panZoomInstance) {
        window.panZoomInstance.destroy();
      }
      
      window.panZoomInstance = panZoomInstance;
    }
    
    function updateZoomIndicator(zoom) {
      const zoomDisplay = document.getElementById('zoomValue');
      if (zoomDisplay) {
        zoomDisplay.textContent = zoom.toFixed(2);
      }
    }
    
    function updatePanLoc(){
      const loc = panZoomInstance.getPan();
      
      document.getElementById('curLocX').textContent = (loc.x * -1).toFixed(2);
      document.getElementById('curLocY').textContent = (loc.y * -1).toFixed(2);
    }

    function initZoom(){
      const observer = new MutationObserver(() => {
        const svg = document.querySelector('#svgOutput svg');
        if (svg) {
          setupZoom(svg);
          observer.disconnect();
        }
      });
      observer.observe(document.getElementById('svgOutput'), { childList: true });
    }
    
    function GOTIME(){
      const output = document.getElementById("graphviz");
      output.value = '';

      const pd = parseData();
      if(Object.keys(dataSets).length === 0){
        alert('No Data. Select a file and check some section checkboxes.');
        return;
      }
      
      const gv = buildGraphViz(pd);
      output.value = gv;
      
      const btn = document.getElementById('GOTIME');
      btn.disabled = true;
      btn.textContent = 'Generating...';
      setTimeout(() => {
        renderSVG(gv);
        initZoom();
        
        
        btn.textContent = 'Generate';
        btn.disabled = false;
        
        document.getElementById('top').style.display = 'none';
        document.getElementById('bottom').style.display = 'block';
        setTimeout(() => {
          findNode('node1');
          document.getElementById('svgOutput').querySelector('svg').querySelectorAll('.foundNode').forEach(n => n.classList.remove('foundNode'));
          alert('Chart Ready!\n\nNavigate around with arrow keys, direction buttons, or click/drag.\nClick on nodes for additional details.\nUse search tool on right to find nodes.');
        }, 10)
        
      }, 10)

    }
    
    function redo(){
        document.getElementById('top').style.display = 'block';
        document.getElementById('bottom').style.display = 'none';
    }
    
    function CLEAR(){
      document.getElementById("parsed").value = '';
      document.getElementById("graphviz").value = '';
    }
    
    function downloadSVG() {
      const svg = document.querySelector('#svgOutput svg');
      if (!svg) return;
      const serializer = new XMLSerializer();
      const source = serializer.serializeToString(svg);
      const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'TM dependency graph.svg';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    document.addEventListener('keydown', (e) => {
      const panStep = 50; // pixels per key press
    
      let dx = 0, dy = 0;
      switch (e.key) {
        case 'ArrowUp':    dy = panStep; break;
        case 'ArrowDown':  dy = -panStep; break;
        case 'ArrowLeft':  dx = panStep; break;
        case 'ArrowRight': dx = -panStep; break;
        default: return; // ignore other keys
      }
    
      e.preventDefault(); // prevent page scroll
      const currentPan = panZoomInstance.getPan();
      panZoomInstance.pan({
        x: currentPan.x + dx,
        y: currentPan.y + dy
      });
      
      updatePanLoc();
    });
    
    document.getElementById('txtSearch').addEventListener('keydown', function (e) {
      if (e.key === 'Enter') {
        e.preventDefault(); // Optional: prevent form submission or page reload
        findNodeByText(this.value);
        document.getElementById('nodeFinder').focus();
      }
    });
  </script>
</body>
</html>
